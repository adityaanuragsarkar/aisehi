<!DOCTYPE html>
<html>
<head>
    <title>For Prativa & Tilak</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #000; color: #ff3366; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100; transition: opacity 1s;
        }
        .spinner { width: 50px; height: 50px; border: 5px solid #333; border-top: 5px solid #ff3366; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #instructions { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: white; text-align: center; z-index: 10; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; }
        #video-hidden { display: none; }
    </style>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <p>Loading Magic for Prativa & Tilak...</p>
    </div>
    <div id="instructions">Show a <b>Peace Sign (✌️)</b> to reveal the message</div>
    <video id="video-hidden" autoplay playsinline></video>

    <script type="importmap">
        { "imports": { 
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        } }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 25;

        const vertexShader = `
            uniform float uMorph; uniform float uTime;
            attribute vec3 targetPosition; varying vec3 vColor;
            void main() {
                vec3 mixedPos = mix(position, targetPosition, uMorph);
                mixedPos.y += sin(uTime + mixedPos.x * 0.5) * 0.2;
                vec4 mvPosition = modelViewMatrix * vec4(mixedPos, 1.0);
                gl_PointSize = (6.0 + sin(uTime * 3.0) * 2.0) * (15.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
                vColor = mix(vec3(0.2, 0.5, 1.0), vec3(1.0, 0.1, 0.4), uMorph);
            }
        `;
        const fragmentShader = `varying vec3 vColor; void main() { if (length(gl_PointCoord - vec2(0.5)) > 0.5) discard; gl_FragColor = vec4(vColor, 0.8); }`;

        const count = 12000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        const target = new Float32Array(count * 3);
        for(let i=0; i<count; i++){
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            pos[i*3] = 10 * Math.sin(phi) * Math.cos(theta);
            pos[i*3+1] = 10 * Math.sin(phi) * Math.sin(theta);
            pos[i*3+2] = 10 * Math.cos(phi);
            const t = Math.random() * Math.PI * 2;
            target[i*3] = 0.7 * (16 * Math.pow(Math.sin(t), 3));
            target[i*3+1] = 0.7 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
            target[i*3+2] = (Math.random() - 0.5) * 3;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('targetPosition', new THREE.BufferAttribute(target, 3));
        const mat = new THREE.ShaderMaterial({ uniforms: { uMorph: { value: 0 }, uTime: { value: 0 } }, vertexShader, fragmentShader, transparent: true, blending: THREE.AdditiveBlending });
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        const textGroup = new THREE.Group();
        scene.add(textGroup);
        new FontLoader().load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', (font) => {
            const tMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
            const g1 = new TextGeometry("I Love U Prativa", { font, size: 1.2, height: 0.1 }); g1.center();
            const m1 = new THREE.Mesh(g1, tMat); m1.position.y = 1;
            
            // REMOVED '2' HERE
            const g2 = new TextGeometry("and Tilak", { font, size: 1, height: 0.1 }); g2.center();
            const m2 = new THREE.Mesh(g2, tMat.clone()); m2.position.y = -1;
            
            textGroup.add(m1, m2);
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => document.getElementById('loader').remove(), 1000);
        });

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
        hands.onResults((res) => {
            if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                const m = res.multiHandLandmarks[0];
                const peace = (m[8].y < m[6].y && m[12].y < m[10].y && m[16].y > m[14].y);
                mat.uniforms.uMorph.value += ((peace ? 1.0 : 0.0) - mat.uniforms.uMorph.value) * 0.1;
                textGroup.children.forEach(c => c.material.opacity = mat.uniforms.uMorph.value);
                points.rotation.y = textGroup.rotation.y = (m[0].x - 0.5) * 2;
            }
        });
        new Camera(document.getElementById('video-hidden'), { onFrame: async () => { await hands.send({image: document.getElementById('video-hidden')}); } }).start();
        function animate() { requestAnimationFrame(animate); mat.uniforms.uTime.value += 0.05; renderer.render(scene, camera); }
        animate();
    </script>
</body>
</html>
